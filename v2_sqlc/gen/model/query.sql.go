// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.22.0
// source: query.sql

package model

import (
	"context"
	"time"
)

const createChain = `-- name: CreateChain :one
INSERT INTO chains (created_at, updated_at, name, chain_id)
VALUES
    (NOW(), NOW(), $1::TEXT, $2::TEXT)
ON CONFLICT (chain_id)
DO
    UPDATE SET updated_at=NOW(), name=EXCLUDED.name
RETURNING id, created_at, updated_at, name, chain_id
`

type CreateChainParams struct {
	Name    string
	ChainID string
}

func (q *Queries) CreateChain(ctx context.Context, arg CreateChainParams) (Chain, error) {
	row := q.db.QueryRowContext(ctx, createChain, arg.Name, arg.ChainID)
	var i Chain
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Name,
		&i.ChainID,
	)
	return i, err
}

const createPrice = `-- name: CreatePrice :one
INSERT INTO prices (created_at, updated_at, token_id, price, timestamp)
VALUES
    (NOW(), NOW(), (
        SELECT tokens.id
            FROM tokens
            JOIN chains ON tokens.chain_id = chains.id
            WHERE chains.chain_id = $1::TEXT AND tokens.denom = $2::TEXT
    ), $3::TEXT, $4::TIMESTAMPTZ)
ON CONFLICT (token_id, timestamp)
DO UPDATE SET
    updated_at=NOW(),
    price=EXCLUDED.price
RETURNING id, created_at, updated_at, token_id, timestamp, price
`

type CreatePriceParams struct {
	ChainID   string
	Denom     string
	Price     string
	Timestamp time.Time
}

func (q *Queries) CreatePrice(ctx context.Context, arg CreatePriceParams) (Price, error) {
	row := q.db.QueryRowContext(ctx, createPrice,
		arg.ChainID,
		arg.Denom,
		arg.Price,
		arg.Timestamp,
	)
	var i Price
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.TokenID,
		&i.Timestamp,
		&i.Price,
	)
	return i, err
}

const createToken = `-- name: CreateToken :one
INSERT INTO tokens (created_at, updated_at, chain_id, name, denom, decimals)
VALUES (
    NOW(),
    NOW(),
    (SELECT id FROM chains WHERE chain_id = $1::TEXT),
    $2::TEXT,
    $3::TEXT,
    $4::INT
)
ON CONFLICT (chain_id, denom)
DO UPDATE SET
        updated_at=NOW(),
        chain_id=EXCLUDED.chain_id,
        name=EXCLUDED.name,
        denom=EXCLUDED.denom,
        decimals=EXCLUDED.decimals
RETURNING id, created_at, updated_at, chain_id, name, denom, decimals
`

type CreateTokenParams struct {
	ChainID  string
	Name     string
	Denom    string
	Decimals int32
}

func (q *Queries) CreateToken(ctx context.Context, arg CreateTokenParams) (Token, error) {
	row := q.db.QueryRowContext(ctx, createToken,
		arg.ChainID,
		arg.Name,
		arg.Denom,
		arg.Decimals,
	)
	var i Token
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ChainID,
		&i.Name,
		&i.Denom,
		&i.Decimals,
	)
	return i, err
}

const getChains = `-- name: GetChains :one
SELECT id, created_at, updated_at, name, chain_id
FROM chains
WHERE chain_id = $1::TEXT
ORDER BY chain_id
`

func (q *Queries) GetChains(ctx context.Context, chainID string) (Chain, error) {
	row := q.db.QueryRowContext(ctx, getChains, chainID)
	var i Chain
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Name,
		&i.ChainID,
	)
	return i, err
}

const getPrices = `-- name: GetPrices :many
SELECT prices.id, prices.created_at, prices.updated_at, prices.token_id, prices.timestamp, prices.price
FROM prices
JOIN tokens ON prices.token_id=tokens.id
JOIN chains ON tokens.chain_id=chains.id
WHERE chains.chain_id = $1::TEXT
  AND tokens.denom = $2::TEXT
ORDER BY prices.timestamp
`

type GetPricesParams struct {
	ChainID string
	Denom   string
}

func (q *Queries) GetPrices(ctx context.Context, arg GetPricesParams) ([]Price, error) {
	rows, err := q.db.QueryContext(ctx, getPrices, arg.ChainID, arg.Denom)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Price
	for rows.Next() {
		var i Price
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.TokenID,
			&i.Timestamp,
			&i.Price,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getToken = `-- name: GetToken :one
SELECT tokens.id, tokens.created_at, tokens.updated_at, tokens.chain_id, tokens.name, tokens.denom, tokens.decimals
FROM tokens
JOIN chains ON tokens.chain_id = chains.id
WHERE chains.chain_id = $1::TEXT
  AND tokens.denom = $2::TEXT
ORDER BY (chains.chain_id, denom)
`

type GetTokenParams struct {
	ChainID string
	Denom   string
}

func (q *Queries) GetToken(ctx context.Context, arg GetTokenParams) (Token, error) {
	row := q.db.QueryRowContext(ctx, getToken, arg.ChainID, arg.Denom)
	var i Token
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ChainID,
		&i.Name,
		&i.Denom,
		&i.Decimals,
	)
	return i, err
}
